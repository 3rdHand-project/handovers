#!/usr/bin/env python
import rospy
from reba_optim.reba_optimization import RebaOptimization
import rospkg
import tf
import json
import sys
from os.path import join
from baxter_commander.persistence import statetodict
# from visualization_msgs.msg import Marker

if __name__ == "__main__":
    rospy.init_node('reba_calibrator')
    rospack = rospkg.RosPack()
    pkg_dir = rospack.get_path('reba_optim')
    method = sys.argv[1]
    constrained = (sys.argv[2].lower() == 'true')
    task = sys.argv[3]
    nb_params = int(sys.argv[4])
    nb_points = int(sys.argv[5])
    savefile = sys.argv[6]
    optimizer = sys.argv[7]
    wait = (sys.argv[8].lower() == 'true')
    assessment_method = sys.argv[9]
    update_config = (sys.argv[10].lower() == 'true')
    maxiter = -1

    try:
        laterality = rospy.get_param('/human/laterality')
    except:
        laterality = ''
        while laterality != 'left' and laterality != 'right' and not rospy.is_shutdown():
            rospy.logwarn('Laterality not defined. What is the subject laterality?')
            laterality = raw_input()

    if constrained:
        extension = 'pose_constrained.json'
    else:
        extension = 'pose.json'

    # get name of file to save
    if savefile == 'default':
        output_file = join(pkg_dir, 'tmp', laterality + '_' + method + '_' + task + '_' + extension)
    else:
        output_file = sys.argv[6]

    # initialize tf
    tfl = tf.TransformListener()
    rospy.sleep(1)

    output_dict = {}

    # by default hip and ankles angles are fixed
    fixed_joints = {}
    fixed_joints['right_hip_0'] = 0.
    fixed_joints['right_hip_1'] = 0.
    fixed_joints['right_hip_2'] = 0.
    fixed_joints['right_knee_0'] = 0.
    fixed_joints['right_ankle_0'] = 0.
    fixed_joints['right_ankle_1'] = 0.

    fixed_joints['left_hip_0'] = 0.
    fixed_joints['left_hip_1'] = 0.
    fixed_joints['left_hip_2'] = 0.
    fixed_joints['left_knee_0'] = 0.
    fixed_joints['left_ankle_0'] = 0.
    fixed_joints['left_ankle_1'] = 0.

    # initialize parameters
    parameters = {}
    fixed_frames = {}

    # set the optimizer between gradient or evolution
    parameters['optimizer'] = optimizer
    parameters['assessment_method'] = assessment_method

    # get initial pose of the object
    try:
        parameters['object_pose'] = rospy.get_param('/object/pose')
    except:
        parameters['object_pose'] = [[0.5, 0.0, 0.2], [0, 0, 0, 1]]
    # parameters depend to the method
    if method == 'reba':
        f_reba = 1
        f_proxemics = 50
        f_sight = 5

    elif method == 'naive':
        f_reba = 0.1
        f_proxemics = 0.0
        f_sight = 0.5
        # fixed frames are calculated according to granjean recommandations
        human_lengths = rospy.get_param('/human/lengths')
        x = 2.0 / 3.0 * (human_lengths['forearm_length'] + human_lengths['upper_arm_length'])
        if laterality == 'right':
            y = -0.1
        else:
            y = 0.1
        z = human_lengths['spine_down_length'] + human_lengths['spine_up_length']

        fixed_frames['human/' + laterality + '_wrist'] = [[x, y, z], [0, 0, 0, 1]]
        # only position is important, rotation is irrelevant
        parameters['fixed_frame_coeffs'] = [1, 0]
        # fix the spine to avoid wrong back posture
        fixed_joints['spine_0'] = 0
        fixed_joints['spine_1'] = 0

    elif method == 'bestick':
        f_reba = 0.1
        f_proxemics = 0.0
        f_sight = 0.5
        # fix the spine to avoid wrong back posture
        fixed_joints['spine_0'] = 0
        # fix elbow and shoulder to ba at half range
        if laterality == 'right':
            fixed_joints['right_shoulder_1'] = 0.4
            fixed_joints['right_elbow_0'] = 1.57
        else:
            fixed_joints['left_shoulder_1'] = -0.4
            fixed_joints['left_elbow_0'] = -1.57

    # constrain the arm if required
    if constrained:
        fixed_joints[laterality + '_elbow_0'] = 0.

    parameters['cost_factors'] = [f_reba, f_proxemics, f_sight]
    optim = RebaOptimization(params=parameters)

    rospy.loginfo('Calibrating the hand-over location.')
    # generate a random pose to start the optimization
    rand_state = optim.model.get_random_state()
    # rand_state = optim.model.get_initial_state()

    # optimize to find the pose of the hand
    res, cost_details = optim.optimize_posture(rand_state, task,
                                               side=laterality, nb_points=nb_points,
                                               fixed_joints=fixed_joints,
                                               fixed_frames=fixed_frames,
                                               group_names='upper_body',
                                               maxiter=maxiter,
                                               nb_params=nb_params)
    # save the joints config
    output_dict['state'] = []
    output_dict[laterality] = []
    for i in range(nb_points):
        output_state = res[i]
        output_dict['state'].append(statetodict(output_state))
        optim.model.send_state(output_state)

        rospy.sleep(1)

        # get the pose of the hand wrt to the base
        fk = optim.model.forward_kinematic(output_state)
        output_dict[laterality].append(fk['human/' + laterality + '_hand'])
    # add detail of cost
    output_dict['trajectory_costs'] = cost_details
    output_dict['object_pose'] = optim.object_pose
    if task == 'welding':
        output_dict['welding_points'] = optim.welding_points
    # write the config file
    with open(output_file, 'w') as outfile:
        json.dump(output_dict, outfile, sort_keys=True, indent=4)

    if update_config:
        config_file = join(pkg_dir, 'config', 'reba_pose.json')
        with open(config_file) as datafile:
            pose_dict = json.load(datafile)
        # update reba config file
        pose_dict[laterality] = output_dict[laterality][0]
        with open(config_file, 'w') as outfile:
            json.dump(pose_dict, outfile, sort_keys=True, indent=4)
    # # close only when enter pressed
    if wait:
        rospy.loginfo("Calibration complete. Press enter to close.")
        raw_input()
