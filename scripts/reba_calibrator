#!/usr/bin/env python
import rospy
from reba_optim.reba_optimization import RebaOptimization
import rospkg
import numpy as np
import tf
import json
import sys
from os.path import join
from baxter_commander.persistence import statetodict
# from visualization_msgs.msg import Marker

if __name__ == "__main__":
    rospy.init_node('reba_calibrator')
    rospack = rospkg.RosPack()
    pkg_dir = rospack.get_path('reba_optim')
    method = sys.argv[1]
    constrained = (sys.argv[2].lower() == 'true')
    if constrained:
        extension = '_pose_constrained.json'
    else:
        extension = '_pose.json'
    output_file = join(pkg_dir, 'tmp', method + extension)
    rospack = rospkg.RosPack()
    # initialize tf
    tfl = tf.TransformListener()
    rospy.sleep(5)

    output_dict = {}
    try:
        laterality = rospy.get_param('/human/laterality')
    except:
        laterality = ''
        while laterality != 'left' and laterality != 'right' and not rospy.is_shutdown():
            rospy.logwarn('Laterality not defined. What is the subject laterality?')
            laterality = raw_input()

    # by default hip and ankles angles are fixed
    fixed_joints = {}
    fixed_joints['right_hip_0'] = 0.
    fixed_joints['right_hip_1'] = 0.
    fixed_joints['right_hip_2'] = 0.
    fixed_joints['right_knee'] = 0.
    fixed_joints['right_ankle_0'] = 0.
    fixed_joints['right_ankle_1'] = 0.

    fixed_joints['left_hip_0'] = 0.
    fixed_joints['left_hip_1'] = 0.
    fixed_joints['left_hip_2'] = 0.
    fixed_joints['left_knee'] = 0.
    fixed_joints['left_ankle_0'] = 0.
    fixed_joints['left_ankle_1'] = 0.

    # initialize parameters
    parameters = {}
    fixed_frames = {}
    # parameters depend to the method
    if method == 'reba':
        f_reba = 1
        f_proxemics = 100
        f_sight = 5

    elif method == 'naive':
        f_reba = 0.1
        f_proxemics = 0.0
        f_sight = 0.5
        # fixed frames are calculated according to granjean recommandations
        human_lengths = rospy.get_param('/human/lengths')
        x = 2.0 / 3.0 * (human_lengths['forearm_length'] + human_lengths['upper_arm_length'])
        if laterality == 'right':
            y = -0.1
        else:
            y = 0.1
        z = human_lengths['spine_down_length'] + human_lengths['spine_up_length']

        fixed_frames[laterality + '_wrist'] = [[x, y, z], [0, 0, 0, 1]]
        # only position is important, rotation is irrelevant
        parameters['fixed_frame_coeffs'] = [1, 0]
        # fix the spine to avoid wrong back posture
        fixed_joints['spine_0'] = 0
        fixed_joints['spine_1'] = 0

    elif method == 'bestick':
        f_reba = 0.1
        f_proxemics = 0.0
        f_sight = 0.5
        # fix the spine to avoid wrong back posture
        fixed_joints['spine_0'] = 0
        # fix elbow and shoulder to ba at half range
        if laterality == 'right':
            fixed_joints['right_shoulder_1'] = 0.4
            fixed_joints['right_elbow_0'] = 1.57
        else:
            fixed_joints['left_shoulder_1'] = -0.4
            fixed_joints['left_elbow_0'] = -1.57

    # constrain the arm if required
    if constrained:
        fixed_joints[laterality + '_elbow_0'] = 0.

    parameters['cost_factors'] = [f_reba, f_proxemics, f_sight]
    optim = RebaOptimization(params=parameters)

    rospy.loginfo('Calibrating the hand-over location.')
    # generate a random pose to start the optimization
    rand_state = optim.model.get_random_state()

    # optimize to find the pose of the hand
    res, cost_details = optim.optimize_posture(rand_state, 'receive',
                                               side=laterality, nb_points=1,
                                               fixed_joints=fixed_joints,
                                               fixed_frames=fixed_frames,
                                               group_names=[laterality + '_arm', 'head'])
    # save the joints config
    output_state = res[-1]
    output_dict['state'] = statetodict(output_state)
    optim.model.send_state(output_state)
    # get the pose of the hand wrt to the base
    fk = optim.model.forward_kinematic(output_state)
    output_dict[laterality] = fk[laterality + '_hand']
    # add detail of cost
    output_dict['trajectory_costs'] = cost_details
    # write the config file
    with open(output_file, 'w') as outfile:
        json.dump(output_dict, outfile, sort_keys=True, indent=4)

    # close only when enter pressed
    rospy.loginfo("Calibration complete. Press enter to close.")
    raw_input()
