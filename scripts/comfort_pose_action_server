#!/usr/bin/env python

import rospy
import tf
import transformations
from rospkg import RosPack
from scipy.io import loadmat
from baxter_commander import ArmCommander
from actionlib import SimpleActionServer
from reba_optim.msg import RebaHandOverAction, RebaHandOverResult, RebaHandOverFeedback
from reba_optim.srv import TrajectoryFromReba, RebaPose, RebaPoseRequest, TrajectoryFromRebaRequest

class ComfortPoseAS(object):
    def __init__(self, name, side):
        self.action_name = name
        self.reba_name = '/reba/get_reba'
        self.traj_name = '/reba/trajectory_from_reba'
        self.world_frame = '/vrep_frame'
        self.tfl = tf.TransformListener()
        self.arm = ArmCommander(side)
        self.rospack = RosPack()

        for srv in [self.reba_name, self.traj_name]:
            rospy.loginfo('[Comfort Pose AS] Waiting for {}...'.format(srv))
            rospy.wait_for_service(srv)

        self.reba_service = rospy.ServiceProxy(self.reba_name, RebaPose)
        self.traj_service = rospy.ServiceProxy(self.traj_name, TrajectoryFromReba)

        self.server = SimpleActionServer(self.action_name, RebaHandOverAction, execute_cb=self.execute_cb, auto_start = False)
        self.server.start()
        self.feedback = RebaHandOverFeedback()
        self.result = RebaHandOverResult()

        with open(self.rospack.get_path("reba_optim")+"/config/baxterRest.mat") as f:
            home_pose_mat = loadmat(f)

        self.home_pose = self.arm.get_current_state()
        self.home_pose.joint_state.position = home_pose_mat['qRest'][0]

        self.go_to_home_pose()
        rospy.loginfo('[Comfort Pose AS] Ready to execute comfortable poses!')

    def go_to_home_pose(self):
        self.arm.move_to_controlled(self.home_pose)

    def execute_cb(self, goal):
        self.go_to_home_pose()
        rospy.sleep(1)
        try:
            object_pose = self.tfl.lookupTransform(self.world_frame, goal.object, rospy.Time(0))
            hip_pose = self.tfl.lookupTransform(self.world_frame, '/human/hip', rospy.Time(0))
        except tf.LookupException, e:
            rospy.logerr(e.message)
            return self.server.set_aborted()

        self.feedback.state = RebaHandOverFeedback.STATE_COMPUTING_REBA
        self.server.publish_feedback(self.feedback)

        reba_request = RebaPoseRequest()
        reba_request.hip_pose = transformations.list_to_pose(hip_pose).pose
        hand_over_location = self.reba_service(reba_request).hand_over_location

        self.feedback.state = RebaHandOverFeedback.STATE_COMPUTING_TRAJECTORIES
        self.server.publish_feedback(self.feedback)

        traj_request = TrajectoryFromRebaRequest()
        traj_request.object_location = transformations.list_to_pose(object_pose).pose
        traj_request.hand_over_location = hand_over_location
        trajectories = self.traj_service(traj_request)

        trajectory_to_object = trajectories.trajectory_to_object
        trajectory_to_handover = trajectories.trajectory_to_handover

        # Trajectory execution
        self.feedback.state = RebaHandOverFeedback.STATE_RUNNING_TRAJECTORY_TO_OBJECT
        self.server.publish_feedback(self.feedback)
        grasp_success = self.arm.execute(trajectory_to_object)

        rospy.sleep(10)

        if not grasp_success:
            rospy.logerr("Grasp failed during execution")
            return self.server.set_aborted()

        self.feedback.state = RebaHandOverFeedback.STATE_RUNNING_TRAJECTORY_TO_HANDOVER
        self.server.publish_feedback(self.feedback)
        grasp_success = self.arm.execute(trajectory_to_handover)

        if not grasp_success:
            rospy.logerr("Handover failed during execution")
            return self.server.set_aborted()

        rospy.loginfo('Handover succeeded')
        self.server.set_succeeded(self.result)

if __name__ == '__main__':
    rospy.init_node('comfort_pose_action_server')
    ComfortPoseAS('/reba/comfort_pose_action_server', 'right')
    rospy.spin()