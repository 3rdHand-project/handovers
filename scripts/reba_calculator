#!/usr/bin/env python
from reba_optim.reba_assess import RebaAssess
from sensor_msgs.msg import JointState
import plotly.plotly as py
from plotly.graph_objs import *
import plotly.tools as tls
import rospy
import numpy as np
from threading import Lock
from collections import deque
from human_moveit_config.human_model import HumanModel
from tools.unity_bridge import UnityBridge
from reba_optim.srv import PosturalOptimization


class RebaCalculator(object):
    def __init__(self):
        self.model = HumanModel()
        self.reba = RebaAssess()
        self.reba_buffer = {}
        self.buffer_size = 2
        self.max_time_reset = rospy.Duration(5)
        self.last_time_message = rospy.get_rostime()
        self.reset = True
        self.timelock = Lock()
        self.groups = [['spine', 3], ['neck', 3], ['left_shoulder', 2], ['right_shoulder', 2],
                       ['left_elbow', 1], ['right_elbow', 1], ['left_wrist', 3], ['right_wrist', 3]]
        for key in self.groups:
            self.reba_buffer[key[0]] = deque(maxlen=self.buffer_size)
        self.reba_buffer['total'] = deque(maxlen=self.buffer_size)
        self.stream_index = 0
        self.init_plotly_streaming()
        self.bridge = UnityBridge()
        # wait for optimization service
        rospy.wait_for_service('/reba/postural_optimization')
        self.reba_optimization = rospy.ServiceProxy('/reba/postural_optimization', PosturalOptimization)

    def init_plotly_streaming(self):
        stream_ids = tls.get_credentials_file()['stream_ids']
        # create sublplot figure
        fig = tls.make_subplots(rows=3, cols=4, specs=[[{}, {}, {}, {}],
                                                       [{}, {}, {}, {}],
                                                       [{'colspan': 4}, None, None, None]],
                                subplot_titles=('Spine', 'Neck', 'Left Shoulder', 'Right Shoulder',
                                                'Left Elbow', 'Right Elbow', 'Left Wrist', 'Right Wrist',
                                                'Total'))

        self.score_range = {}
        self.score_range['spine'] = [0, 7]
        self.score_range['neck'] = [0, 4]
        self.score_range['left_shoulder'] = [0, 8]
        self.score_range['right_shoulder'] = [0, 8]
        self.score_range['left_elbow'] = [0, 5]
        self.score_range['right_elbow'] = [0, 5]
        self.score_range['left_wrist'] = [0, 5]
        self.score_range['right_wrist'] = [0, 5]
        # add the layout
        fig['layout'].update(showlegend=False, title='REBA Score')
        for i, g in enumerate(self.groups):
            fig['layout']['yaxis' + str(i + 1)].update(title='score', range=self.score_range[g[0]])
        fig['layout']['yaxis9'].update(title='score', range=[0, 10])

        # aplly layout for the 3d model
        scene = dict(xaxis=dict(range=[-1, 1]),
                     yaxis=dict(range=[-1, 1]),
                     zaxis=dict(range=[-0.5, 1]),
                     camera=dict(eye=dict(x=1.7, y=1.7, z=0.5)))
        fig['layout']['scene1'].update(scene)

        # Get stream id from stream id list
        for i, g in enumerate(self.groups):
            stream = Stream(
                token=stream_ids[i],  # (!) link stream id to 'token' key
                maxpoints=10     # (!) keep a max of 80 pts on screen
            )
            # Initialize trace of streaming plot by embedding the unique stream_id
            trace = Scatter(
                x=[],
                y=[],
                mode='lines+markers',
                stream=stream         # (!) embed stream id, 1 per trace
            )
            # add the trace to the figure
            r = i / 4 + 1
            c = i % 4 + 1
            fig.append_trace(trace, r, c)
        # add total trace
        stream = Stream(
            token=stream_ids[len(self.groups) + 1],  # (!) link stream id to 'token' key
            maxpoints=10     # (!) keep a max of 80 pts on screen
        )
        # Initialize trace of streaming plot by embedding the unique stream_id
        trace = Scatter(
            x=[],
            y=[],
            mode='lines+markers',
            stream=stream         # (!) embed stream id, 1 per trace
        )
        # add the trace to the figure
        fig.append_trace(trace, 3, 1)

        # (@) Send fig to Plotly, initialize streaming plot, open new tab
        py.plot(fig, filename='reba_score')

        # open plotly stream
        self.streams = {}
        for i, g in enumerate(self.groups):
            self.streams[g[0]] = py.Stream(stream_ids[i])
            self.streams[g[0]].open()
        # add total
        self.streams['total'] = py.Stream(stream_ids[len(self.groups) + 1])
        self.streams['total'].open()

    def reset_stream(self):
        self.stream_index = 0
        for g in self.groups:
            self.reba_buffer[g[0]] = deque(maxlen=self.buffer_size)
            self.streams[g[0]].write(dict(x=[], y=[]))
        # reset total
        self.reba_buffer['total'] = deque(maxlen=self.buffer_size)
        self.streams['total'].write(dict(x=[], y=[]))
        # reset model
        # self.streams['model'].write(Scatter3d(x=[], y=[], z=[]))
        self.reset = True
        self.last_time_message = rospy.get_rostime()

    def handle_joint_state_msgs(self, msg):
        self.stream_index += 1
        with self.timelock:
            self.reset = False
            self.last_time_message = rospy.get_rostime()
        # calculate the reba score
        reba_score = self.reba.assess_posture(msg, 'neural_network')
        reba_dict = self.reba.assess_group(msg, self.groups)
        # add the value to the buffer
        self.reba_buffer['total'].append(reba_score)
        avg = np.mean(self.reba_buffer['total'])
        # stream the data to Plotly
        self.streams['total'].write(dict(x=self.stream_index, y=avg))
        risk_list = {}
        for key, value in reba_dict.iteritems():
            self.reba_buffer[key].append(value)
            avg = np.mean(self.reba_buffer[key])
            # stream the data to Plotly
            self.streams[key].write(dict(x=self.stream_index, y=avg))
            s_range = self.score_range[key][1]
            offset_min = 0.
            offset_max = 0.6
            pourcent_reba = min((avg - offset_min * s_range) / ((offset_max - offset_min) * s_range), 1.)
            risk_list[key] = pourcent_reba
        # eventually advertise the risk
        self.bridge.activate_risk_frames(risk_list)
        # optimize the posture to send the ghost
        res = self.reba_optimization(posture=msg, nb_iterations=10)
        self.bridge.send_optimal_posture(res.opt_posture)

    def run(self):
        rate = rospy.Rate(1)
        rospy.Subscriber('/human/set_joint_values', JointState, self.handle_joint_state_msgs)
        while not rospy.is_shutdown():
            # check with latest receive message to reset if necessary
            current_time = rospy.get_rostime()
            with self.timelock:
                if not self.reset and current_time - self.last_time_message > self.max_time_reset:
                    # save previous log
                    self.reba.save_log()
                    self.reset_stream()
                elif current_time - self.last_time_message > rospy.Duration(55):
                    # send a hearthbeat to avoid closing connection
                    self.reset_stream()
            # sleep
            rate.sleep()
        # save the log
        self.reba.save_log()
        # close plotly stream
        for key, s in self.streams.iteritems():
            s.close()


if __name__ == '__main__':
    rospy.init_node('reba_calculator')
    reba_calc = RebaCalculator()
    reba_calc.run()
