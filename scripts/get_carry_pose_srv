#!/usr/bin/env python
import rospy
from thr_infrastructure_msgs.srv import GetCarryPose, GetCarryPoseResponse
from geometry_msgs.msg import PoseStamped
import yaml
import rospkg
import transformations
import json
import tf


class CarryPoseSrv(object):
    def __init__(self, laterality):
        self.laterality = laterality
        self.rospack = rospkg.RosPack()
        self.tfl = tf.TransformListener()
        self.tfb = tf.TransformBroadcaster()
        rospy.Service('thr/get_carry_pose', GetCarryPose, self.handle_carry_pose_requests)
        self.init_poses()

    def init_poses(self):
        # get fixed pose from config file
        pkg_dir = self.rospack.get_path("reba_optim")
        with open(pkg_dir + '/config/fixed_pose.yaml', 'r') as datafile:
            data = yaml.load(datafile)
        # convert data to PoseStamped
        self.fixed_pose = transformations.list_to_pose(data)
        self.fixed_pose.header.frame_id = 'base'
        self.fixed_pose.header.stamp = rospy.get_rostime()

        self.human_poses = {}
        # calculate relative pose from torso and arm length
        human_lengths = rospy.get_param('/human/lengths')
        x = 2 / 3 * (human_lengths['forearm_length'] + human_lengths['upper_arm_length'])
        y = 0.1
        z = human_lengths['spine_down_length'] + human_lengths['spine_up_length']
        # get orientation from demonstration
        with open(pkg_dir + '/config/relative_pose.json') as datafile:
            poses = json.load(datafile)
        # add it to the dictionnary of poses
        self.human_poses['relative'] = {}
        self.human_poses['relative']['right'] = [[x, -y, z], poses['right'][1]]
        self.human_poses['relative']['left'] = [[x, y, z], poses['left'][1]]

        # get reba pose from config file
        with open(pkg_dir + '/config/reba_pose.json') as datafile:
            self.human_poses['reba'] = json.load(datafile)

        # get desired pose from config file
        with open(pkg_dir + '/config/desired_pose.json') as datafile:
            self.human_poses['desired'] = json.load(datafile)

    def handle_carry_pose_requests(self, req):
        if req.method == 'fixed':
            pose = self.fixed_pose
            success = True
        else:
            # open file of poses for shapeo object
            pkg_dir = self.rospack.get_path("thr_scenes")
            with open(pkg_dir + '/config/' + req.object + '/poses.json') as datafile:
                data = json.load(datafile)
            # get the supposed pose of the hand
            ObjTHand = data['/' + req.object]['carry'][self.laterality][req.location]
            HandTObj = transformations.inverse_transform(ObjTHand)
            # get the current user pose
            try:
                self.tfl.waitForTransform('base', '/human/tracker/base', rospy.Time(), rospy.Duration(0.5))
                BaseTHuman = self.tfl.lookupTransform('base', '/human/tracker/base', rospy.Time(0))
                # get the humand hand wrt to human base
                HumanTHand = self.human_poses[req.method][self.laterality]
                # apply chain rule of transformations
                pose = transformations.multiply_transform(BaseTHuman, HumanTHand)
                pose = transformations.multiply_transform(pose, HandTObj)
                # convert pose to PoseStamped
                pose = transformations.list_to_pose(pose)
                pose.header.frame_id = 'base'
                pose.header.stamp = rospy.get_rostime()
                success = True
            # if the human base is not seen send a failure
            # except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
            except Exception:
                success = False
                pose = PoseStamped()
        return GetCarryPoseResponse(success=success, object_pose=pose)

    def run(self):
        rospy.spin()


if __name__ == '__main__':
    rospy.init_node('get_carry_pose_srv')
    laterality = rospy.get_param('/human/laterality')
    c = CarryPoseSrv(laterality)
    print "Ready to receive carry request"
    c.run()
